### Vue使用异步更新队列
异步更新队列指的是当状态发生变化时，Vue异步执行DOM更新。

我们在项目开发中会遇到这样一种场景：
>当我们将状态改变之后想获取更新后的DOM，往往我们获取到的DOM是更新前的旧DOM，我们需要使用vm.$nextTick方法异步获取DOM

### 虚拟DOM的优缺点
>虚拟DOM将DOM树转换成一个JS对象树,diff算法逐层比较,删除,添加操作,但是,如果有多个相同的元素,可能会浪费性能,所以,react和vue-for引入key值进行区分.

虚拟DOM具有批处理和高效的Diff算法,最终表现在DOM上的修改只是变更的部分，可以保证非常高效的渲染,优化性能.
+ A 可以保证性能下限：比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；
+ B 无需手动操作DOM： 不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；
+ D 跨平台： 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。
+ C 无法进行极致优化： 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。比如VScode采用直接手动操作DOM的方式进行极端的性能优化
+ 首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢

### v-if和v-show的区别
     1.v-show是css切换，v-if是完整的销毁和重新创建
     2.v-if是惰性的，只有当条件为真时才会真正渲染标签；如果初始条件不为真，则v-if不会去渲染标签。v-show则无论初始条件是否成立，都会渲染标签，它仅仅做的只是简单的CSS切换。
     3.v-if在条件切换时，会对标签进行适当的创建和销毁，而v-show则仅在初始化时加载一次，因此v-if的开销相对来说会比v-show大。
v-for优先级高于v-if 故如果需要两个都存在，v-if尽量在v-for的父级被包裹，避免增加无用的渲染开销

### 绑定 class 的数组用法
### prop 验证，和默认值
我们在父组件给子组件传值的时候，可以指定该props的默认值及类型，当传递数据类型不正确的时候，vue会发出警告
```vue
props: {
    visible: {
        default: true,
        type: Boolean,
        required: true
    },
},
```
### v-for key的作用
+ 更精准-->在虚拟dom节点中赋予key值 保证了唯一性，可以用于dom的重新渲染或是就地复用<br />
+ 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识<br />
+ 借助 Key 值来判断元素与本地状态的关联关系
+ 高效的更新虚拟DOM
### vue初始化页面闪动问题
    在css里加上[v-cloak] {
        display: none;
    }
    在根元素加上style="display: none;" :style="{display: 'block'}"
### vue中的过滤器如何使用
    Vue.filter()  Vue.filter('过滤器的名称', function(){})
    + 参数1：过滤器名称
    + 参数2：过滤器实现的方法  该方法中有2个参数  
        + 参数1为需要过滤的数据，
        + 参数2为过滤器传递的参数
### vue中组件创建的方式有哪些？
    全局组件和局部组件
    + 全局组件 Vue.component();参数1：组件名称  参数2：组件的配置项
        + 使用 Vue.extend 来创建全局的Vue组件
        + 使用 Vue.component('组件的名称', 创建出来的组件模板对象)
        + 组件的 template 属性指向的模板内容,必须有且只能有唯一的一个根元素
    + 局部组件 new Vue({    components:{} key值为组件名称  val值为组件的配置项 })

### vue组件中data为什么必须是一个函数？
答：在component中，data必须以函数的形式存在，不可以是对象。<br />
&emsp;&emsp;组件中的data写成一个函数，数据以函数返回值的形式定义，这样每次复用组件的时候，都会返回一份新的data，相当于每个组件实例都有自己私有的数据空间，它们只负责各自维护的数据，不会造成混乱。<br />
&emsp;&emsp;而单纯的写成对象形式，就是所有的组件实例共用了一个data，这样改一个全都改了。

+ 当一个组件被定义，data 必须声明为返回一个初始数据对象的函数，因为组件可能被用来创建多个实例。
+ 如果 data 仍然是一个纯粹的对象，则所有的实例将共享引用同一个数据对象
+ 通过提供 data 函数，每次创建一个新实例后，我们能够调用 data 函数，从而返回初始数据的一个全新副本数据对象



### v-on可以监听多个方法吗
```vue
<input type="text" v-on="{ input:onInput,focus:onFocus,blur:onBlur, }">
```
### assets和static的区别
+ 相同点：assets和static两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下
+ 不同点：
    + assets中存放的静态资源文件在项目打包时，也就是运行npm run build时会将assets中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在static文件中跟着index.html一同上传至服务器。
    + static中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是static中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于assets中打包后的文件提交较大点。在服务器中就会占据更大的空间。
+ 建议：将项目中template需要的css样式文件、图片、js文件等都可以放置在assets中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如iconfoont.css等文件可以放置在static中，因为这些引入的第三方文件已经经过处理，我们不再需要处理，直接上传。

### delete和Vue.delete删除数组的区别
    delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变
    Vue.delete 直接删除了数组 改变了数组的键值。
### vue更新数组时触发视图更新的方法
    答： push()；pop()；shift()；unshift()；splice()； sort()；reverse()