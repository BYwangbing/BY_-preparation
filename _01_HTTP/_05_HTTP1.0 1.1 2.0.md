HTTP 超文本传输协议

默认HTTP的端口号为80，HTTPS的端口号为443
# HTTP/1.0
+ HTTP/1.0 版的主要缺点是，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。
+ 无状态、无连接
+ HTTP1.0规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），
+ 服务器不跟踪每个客户端也不记录过去的请求（无状态）。
+ 致命缺点: 就是无法复用TCP连接和并行发送请求
    + 无法复用连接
    + 队头阻塞
    + 耗时 利用率低   
# HTTP/1.1
HTTP1.1是默认支持持久化连接的。HTTP1.0若要支持持久化连接需要显示指定Keep-alived报文头。
+ 持久化连接
    + 即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive
    + 客户端和服务器发现对方一段时间没有活动，就可以主动关闭连接。不过，规范的做法是，客户端在最后一个请求时，发送Connection: close，明确要求服务器关闭TCP连接。
+ 管线化技术
    + 即在同一个TCP连接里面，客户端可以同时发送多个请求
    + “并行”发送请求，但是这个并行，也不是真正意义上的并行，而是可以让我们把先进先出队列从客户端（请求队列）迁移到服务端（响应队列）
    + 虽然通过 pipeline 也能并发请求，但是多个请求之间的响应会被阻塞的
+ 1.1版还新增了许多动词方法：PUT、PATCH、HEAD、 OPTIONS、DELETE。
+ 致命缺点 
    + 明文传输
    + 其实还是没有解决无状态连接的
    + 当有多个请求同时被挂起的时候 就会拥塞请求通道，导致后面请求无法发送
    + 臃肿的消息首部
        + HTTP/1.1能压缩请求内容,但是消息首部不能压缩;
        + 在现今请求中,消息首部占请求绝大部分(甚至是全部)也较为常见.
## keep-alive

# HTTP/2.0
+ 多路复用技术
    + 同域名下所有通信都在单个连接上完成
    + 单个连接可以承载任意数量的双向数据流
    + 所有的请求都是通过一个 TCP 连接并发完成
    + 做到了真正的并发请求
    + HTTP2.0对于同一域名下所有请求都是基于流的 不管对于同一域名访问多少文件，也只建立一路连接
    + 优先级高的流会被优先发送。图片请求的优先级要低于 CSS 和 script
+ header压缩
    + HTTP 2.0 使用 HPACK 算法进行压缩
    + HTTP 1.1版本会出现 「User-Agent、Cookie、Accept、Server、Range」 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。
+ 新的二进制格式
    + HTTP1.x的解析是基于文本
    + HTTP2.0的协议解析决定采用二进制格式
+ 服务端推送
    + 推送资源可以由不同页面共享
    + 服务器可以按照优先级推送资源
    + 客户端可以缓存推送的资源 也可以拒收推送过来的资源
    + 服务器可以对一个客户端请求发送多个响应
+ 流量控制
    + TCP协议通过`sliding window`的算法来做流量控制 发送方有个sending window，接收方有receive window
    
## HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？
+ **HTTP/1.*** 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接
+ **HTTP1.1** 若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞
+ **HTTP2.0** 多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行

